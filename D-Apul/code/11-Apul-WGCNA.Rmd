---
title: "Apul WGCNA"
output: html_document
date: "2024-12-23"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(
  echo = TRUE,         # Display code chunks
  eval = TRUE,         # Evaluate code chunks
  warning = FALSE,     # Hide warnings
  message = FALSE,     # Hide messages
  comment = ""         # Prevents appending '##' to beginning of lines in code output
)
```

To do: 

- Compare with blockwise module approach 
- Troubleshoot correlations with Timepoint and site as categories 
- See if we can run correlations in which some samples have NA with traits (e.g., cre)
- Look at physiology outliers 

# Install and load packages

```{r load_libraries, inlcude = TRUE}
library(tidyverse)
library(ggplot2)
library(WGCNA)
library(magrittr)
library(genefilter)
```

Used Jennifer Chang's Bioinformatic Workflow [post on WGCNA analysis](https://bioinformaticsworkbook.org/tutorials/wgcna.html#gsc.tab=0) as a very helpful guide.

**NOTE: WGCNA is recommended for use with at *least* 15 samples to draw meaningful conclusions. We only have 5 samples from each species in our deep-dive dataset, so this code is primarily intended to be a trial run, developing an RNA-sRNA WGCNA coexpression pipeline in preparation for our *time series data*.**

## Load variance stabilized count data

Load in count matrices for RNAseq. 

```{r load-RNA-counts}
# RNA variance stabilized counts data
genes <- read_csv("D-Apul/output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv")

genes<-as.data.frame(genes)

rownames(genes)<-genes$gene_id

genes<-genes%>%select(!gene_id)

metadata<-read_csv("M-multi-species/data/rna_metadata.csv")%>%select(AzentaSampleName, ColonyID, Timepoint)%>%
  filter(grepl("ACR", ColonyID))

colonies<-unique(metadata$ColonyID)

phys<-read_csv("https://github.com/urol-e5/timeseries/raw/refs/heads/master/time_series_analysis/Output/master_timeseries.csv")%>%filter(colony_id_corr %in% colonies)%>%
  select(colony_id_corr, species, timepoint, site, Host_AFDW.mg.cm2, Sym_AFDW.mg.cm2, Am, AQY, Rd, Ik, Ic, calc.umol.cm2.hr, cells.mgAFDW, prot_mg.mgafdw, Ratio_AFDW.mg.cm2, Total_Chl, Total_Chl_cell, cre.umol.mgafdw)
```

Check that there are no genes with 0 counts across all samples.

```{r}
nrow(genes)

genes<-genes %>%
     mutate(Total = rowSums(.[, 1:40]))%>%
    filter(!Total==0)%>%
    dplyr::select(!Total)

nrow(genes)
```

## pOverA filtering

*pOverA*: Specifying the minimum count for a proportion of samples for each gene. Here, we are using a pOverA of 0.25. This is because we have 40 samples with a minimum of n=10 samples per timepoint Therefore, we will accept genes that are present in 10/40 = 0.25 of the samples because we expect different expression by life stage. We are further setting the minimum count of genes to 10, such that 25% of the samples must have a gene count of >10 in order for the gene to remain in the data set.  

Filter in the package "genefilter". Pre-filtering our dataset to reduce the memory size dataframe, increase the speed of the transformation and testing functions, and improve quality of statistical analysis by removing low-coverage counts. Removed counts could represent outliers in the data and removing these improves sensitivity of statistical tests.   

```{r}
filt <- filterfun(pOverA(0.25,10))

#create filter for the counts data
gfilt <- genefilter(genes, filt)

#identify genes to keep by count filter
gkeep <- genes[gfilt,]

#identify genes to keep by count filter
gkeep <- genes[gfilt,]

#identify gene lists
gn.keep <- rownames(gkeep)

#gene count data filtered in PoverA, P percent of the samples have counts over A
genes_filt <- as.data.frame(genes[which(rownames(genes) %in% gn.keep),])

#How many rows do we have before and after filtering?
nrow(genes) #Before
nrow(genes_filt) #After
```

## Assign metadata and arrange order of columns 

Display current order of metadata and gene count matrix.  
```{r}
metadata$AzentaSampleName
colnames(genes_filt)
```

Order metadata the same as the column order in the gene matrix.  
```{r}
list<-colnames(genes_filt)
list<-as.factor(list)

metadata$AzentaSampleName<-as.factor(metadata$AzentaSampleName)

# Re-order the levels
metadata$AzentaSampleName <- factor(as.character(metadata$AzentaSampleName), levels=list)
# Re-order the data.frame
metadata_ordered <- metadata[order(metadata$AzentaSampleName),]
metadata_ordered$AzentaSampleName
```

Metadata and gene count matrix are now ordered the same. 

## Conduct variance stabilized transformation 

```{r}
library(DESeq2)
#Set DESeq2 design
gdds <- DESeqDataSetFromMatrix(countData = genes_filt,
                              colData = metadata_ordered,
                              design = ~Timepoint)
```

Check size factors. 
```{r}
SF.gdds <- estimateSizeFactors(gdds) #estimate size factors to determine if we can use vst  to transform our data. Size factors should be less than 4 for us to use vst
print(sizeFactors(SF.gdds)) #View size factors

all(sizeFactors(SF.gdds)) < 4
```

All size factors are less than 4, so we can use VST transformation.  

```{r}
gvst <- vst(gdds, blind=FALSE) #apply a variance stabilizing transformation to minimize effects of small counts and normalize wrt library size
head(assay(gvst), 3) #view transformed gene count data for the first three genes in the dataset.  
```

# Conduct permanova and pca 

Export data for PERMANOVA test.  
```{r}
test<-t(assay(gvst)) #export as matrix
test<-as.data.frame(test)

#add category columns
test$Sample<-rownames(test)
test$Timepoint<-metadata$Timepoint[match(test$Sample, metadata$AzentaSampleName)]
```

Build PERMANOVA model.  
```{r}
library(factoextra)
library(vegan)

scaled_test <-prcomp(test%>%select(where(is.numeric)), scale=TRUE, center=TRUE)
fviz_eig(scaled_test)

# scale data
vegan <- scale(test%>%select(where(is.numeric)))

# PerMANOVA 
permanova<-adonis2(vegan ~ Timepoint, data = test, method='eu')
permanova
```

```{r}
library(ggplot2)
library(ggfortify)
library(RColorBrewer)
library(ComplexHeatmap)

pca1<-ggplot2::autoplot(scaled_test, data=test, frame.colour="Timepoint", loadings=FALSE,  colour="Timepoint", loadings.label.colour="black", loadings.colour="black", loadings.label=FALSE, frame=FALSE, loadings.label.size=5, loadings.label.vjust=-1, size=5) + 
  geom_text(aes(x = PC1, y = PC2, label = Sample), vjust = -0.5)+
  theme_classic()+
   theme(legend.text = element_text(size=18), 
         legend.position="right",
        plot.background = element_blank(),
        legend.title = element_text(size=18, face="bold"), 
        axis.text = element_text(size=18), 
        axis.title = element_text(size=18,  face="bold"));pca1
```

Look at sample distances. 
```{r}
gsampleDists <- dist(t(assay(gvst))) #calculate distance matix
gsampleDistMatrix <- as.matrix(gsampleDists) #distance matrix
rownames(gsampleDistMatrix) <- colnames(gvst) #assign row names
colnames(gsampleDistMatrix) <- NULL #assign col names
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255) #assign colors

save_pheatmap_pdf <- function(x, filename, width=7, height=7) {
   stopifnot(!missing(x))
   stopifnot(!missing(filename))
   pdf(filename, width=width, height=height)
   grid::grid.newpage()
   grid::grid.draw(x$gtable)
   dev.off()
}

pht<-pheatmap(gsampleDistMatrix, #plot matrix
         clustering_distance_rows=gsampleDists, #cluster rows
         clustering_distance_cols=gsampleDists, #cluster columns
         col=colors) #set colors

pdf(file="D-Apul/output/11.00-Apul-WGCNA/pheatmap.pdf")
print(pht)
dev.off()
```

# WGCNA

Look for outliers by examining tree of samples  
```{r}
datExpr <- as.data.frame(t(assay(gvst)))

sampleTree = hclust(dist(datExpr), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
pdf("D-Apul/output/11.00-Apul-WGCNA/outliers.pdf")
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
dev.off()
```

Soft threshold selection. The soft thresholding power (Î²) is the number to which the co-expression similarity is raised to calculate adjacency. The function pickSoftThreshold performs a network topology analysis. The user chooses a set of candidate powers, however the default parameters are suitable values.  
```{r, message=FALSE, warning=FALSE}
allowWGCNAThreads()
# # Choose a set of soft-thresholding powers
powers <- c(seq(from = 1, to=19, by=2), c(21:30)) #Create a string of numbers from 1 through 10, and even numbers from 10 through 20
# 
# # Call the network topology analysis function
sft <-pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
```

Plot the results.  
```{r}
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# # # Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
      xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
 text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# # # this line corresponds to using an R^2 cut-off
 abline(h=0.9,col="red")
# # # Mean connectivity as a function of the soft-thresholding power
 plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
 text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```
I used a scale-free topology fit index **R^2 of 0.9**. This lowest recommended R^2 by Langfelder and Horvath is 0.8. I chose 0.9 because we want to use the smallest soft thresholding power that maximizes with model fit. It appears that our **soft thresholding power is 5** because it is the lowest power above the R^2=0.9 threshold that maximizes with model fit.  

Co-expression similarity and adjacency, using the soft thresholding power 5 and translate the adjacency into topological overlap matrix to calculate the corresponding dissimilarity. I will use a **signed network**.  
```{r, }
# #Set up workspace
#getwd() #Display the current working directory
# #If necessary, change the path below to the directory where the data files are stored. "." means current directory. On Windows use a forward slash / instead of the usual \.
#workingDir = ".";
# setwd(WGCNA_dev);
# library(WGCNA) #Load the WGCNA package
options(stringsAsFactors = FALSE) #The following setting is important, do not omit.
enableWGCNAThreads() #Allow multi-threading within WGCNA. 
# 
# #Load the data saved in the first part
adjTOM <- datExpr
adjTOM
# 
# #Run analysis
softPower=5 #Set softPower to 5
adjacency=adjacency(datExpr, power=softPower,type="signed") #Calculate adjacency

TOM = TOMsimilarity(adjacency,TOMType = "signed") #Translate adjacency into topological overlap matrix
#this step can take awhile 

dissTOM= 1-TOM #Calculate dissimilarity in TOM

```

### Clustering using TOM

Form distance matrix  
```{r}
library(flashClust)
geneTree=flashClust(as.dist(dissTOM), method="average")
```

### Module identification using dynamicTreeCut  

Module identification is essentially cutting the branches off the tree in the dendrogram above. We like large modules, so we set the **minimum module size** relatively high, so we will set the minimum size at 30. 

```{r}
minModuleSize = 30
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
deepSplit = TRUE, pamRespectsDendro = FALSE,
minClusterSize = minModuleSize)
table<-as.data.frame(table(dynamicMods)) #list modules and respective sizes
table(dynamicMods)
```
Module 0 is reserved for unassigned genes. The are other modules will be listed largest to smallest. 

dynamicMods
   1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26 
5333 4868 4225 1256  369  275  267  252  215  200  194  178  173  173  157  148  135  135  129  128  126  124  103  103  102  102 
  27   28   29   30   31   32   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47 
  95   94   93   91   86   82   72   71   58   56   45   45   44   44   43   40   37   34   31   31   30 


Plot the module assignment under the gene dendrogram
```{r}
#dynamicColors = labels2colors(dynamicMods) # Convert numeric labels into colors
dynamicColors=dynamicMods
table(dynamicColors)
```

### Merge modules with similar expression profiles  

Plot module similarity based on eigengene value 
```{r}
#Calculate eigengenes
MEList = moduleEigengenes(datExpr, colors = dynamicColors, softPower = 5)
MEs = MEList$eigengenes

#Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs)

#Cluster again and plot the results
METree = flashClust(as.dist(MEDiss), method = "average")
```

**Merge modules with >85% eigengene similarity.** Most studies use somewhere between 80-90% similarity. I will use 85% similarity as my merging threshold.
```{r}
MEDissThres= 0.15 #merge modules that are 85% similar

plot(METree, main = "Clustering of module eigengenes", xlab = "", sub = "")
abline(h=MEDissThres, col="red")
dev.off()

merge= mergeCloseModules(datExpr, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors= merge$colors
mergedMEs= merge$newMEs

pdf("D-Apul/output/11.00-Apul-WGCNA/merged-modules.pdf", height=12, width=12)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)
dev.off()
```


Save new colors
```{r}
moduleLabels=mergedColors
moduleColors = mergedColors # Rename to moduleColors
#colorOrder = c("grey", standardColors(50)); # Construct numerical labels corresponding to the colors
#moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;
ncol(MEs) #How many modules do we have now?
```

We have 36 modules now. 

Plot new tree  
```{r}
#Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs)
#Cluster again and plot the results
pdf(file="D-Apul/output/11.00-Apul-WGCNA/eigengeneClustering.pdf")
METree = flashClust(as.dist(MEDiss), method = "average")
MEtreePlot = plot(METree, main = "Clustering of module eigengenes", xlab = "", sub = "")
dev.off()
```

Display table of module gene counts.  

```{r}
table(mergedColors)
table<-as.data.frame(table(mergedColors))
```

We have 9 modules.   

mergedColors
   1    2    5    7    8    9   10   13   14   15   16   17   18   19   21   22   24   25   26   28   30   31   32   33   35   37 
5333 4868  472  338  446 4618  293 1832  173  157  148  135  135  129  221  124  159  102  102   94   91   86   82   72   58   45 
  38   39   40   41   42   43   44   45   46   47 
  45   44   44   43   40   37   34   31   31   30 

## Correlate to traits 

Remove sample from expression data that is not present in physiological data. 1B9
```{r}
phys<-phys%>%mutate(Timepoint=if_else(timepoint=="timepoint1","TP1", 
                        if_else(timepoint=="timepoint2", "TP2", 
                                if_else(timepoint=="timepoint3", "TP3", 
                                  if_else(timepoint=="timepoint4", "TP4", NA)))))

phys$Timepoint

phys$Code <- paste0(phys$colony_id_corr, "_", phys$Timepoint)

metadata_ordered$Code<-paste0(metadata_ordered$ColonyID, "_", metadata_ordered$Timepoint)

setdiff(metadata_ordered$Code, phys$Code)

metadata_ordered%>%filter(Code=="ACR-265_TP4")

datExpr<-datExpr%>%filter(!rownames(.)=="1B9")

setdiff(rownames(datExpr), metadata_ordered$AzentaSampleName)
```

Create a physiological/factor dataset with sample in rows and phys data in columns (row name = Azenta sample name)
```{r}
phys$AzentaSampleName<-metadata_ordered$AzentaSampleName[match(phys$Code, metadata_ordered$Code)]

traits<-phys%>%
  select(AzentaSampleName, Timepoint, site, Host_AFDW.mg.cm2, Sym_AFDW.mg.cm2, Am, Rd, cells.mgAFDW, Total_Chl, Ratio_AFDW.mg.cm2)

#time point
#site
traits<-traits%>%
  mutate(site=if_else(site=="Mahana", "1", 
                      if_else(site=="Manava", "2", NA)))%>%
  mutate(Timepoint=gsub("TP", "", Timepoint))

traits$Timepoint<-as.numeric(traits$Timepoint)
traits$site<-as.numeric(traits$site)

traits<-as.data.frame(traits)
rownames(traits)<-traits$AzentaSampleName

datTraits<-traits%>%select(!AzentaSampleName)

datTraits<-datTraits%>%select(!Timepoint)%>%select(!site)
```

```{r}
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)

nGenes
nSamples
```

Generate labels for module eigengenes as numbers.  
```{r}
MEs0 = moduleEigengenes(datExpr, moduleLabels, softPower=5)$eigengenes
MEs = orderMEs(MEs0)
names(MEs)
```

Correlations of traits with eigengenes
```{r}
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
Colors=sub("ME","", names(MEs))

moduleTraitTree = hclust(dist(t(moduleTraitCor)), method = "average")

pdf(file="D-Apul/output/11.00-Apul-WGCNA/ModuleTraitClusterTree.pdf")
plot(moduleTraitTree)
dev.off()
```

Correlations of genes with eigengenes. Calculate correlations between ME's and lifestages. 
```{r}
moduleGeneCor=cor(MEs,datExpr)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);
```

Calculate kME values (module membership). 

```{r}
datKME = signedKME(datExpr, MEs, outputColumnName = "kME")
head(datKME)
```

Generate a complex heatmap of module-trait relationships.  

```{r}
#bold sig p-values
#dendrogram with WGCNA MEtree cut-off
#colored y-axis

#Create list of pvalues for eigengene correlation with specific life stages
heatmappval <- signif(moduleTraitPvalue, 1)

#Make list of heatmap row colors
htmap.colors <- names(MEs)
htmap.colors <- gsub("ME", "", htmap.colors)

library(dendsort)
row_dend = dendsort(hclust(dist(moduleTraitCor)))
col_dend = dendsort(hclust(dist(t(moduleTraitCor))))

pdf(file = "D-Apul/output/11.00-Apul-WGCNA/Module-trait-relationship-heatmap.pdf", height = 12, width = 8)
Heatmap(moduleTraitCor, name = "Eigengene", row_title = "Gene Module", column_title = "Module-Lifestage Eigengene Correlation", 
        col = blueWhiteRed(50), 
        row_names_side = "left", 
        #row_dend_side = "left",
        width = unit(5, "in"), 
        height = unit(6.5, "in"), 
        #column_dend_reorder = TRUE, 
        #cluster_columns = col_dend,
        row_dend_reorder = TRUE,
        #column_split = 6,
        row_split=3,
        #column_dend_height = unit(.5, "in"),
        #column_order = lifestage_order, 
        cluster_rows = row_dend, 
        row_gap = unit(2.5, "mm"), 
        border = TRUE,
        cell_fun = function(j, i, x, y, w, h, col) {
        if(heatmappval[i, j] < 0.05) {
            grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "bold"))
        }
        else {
            grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "plain"))
        }},
        column_names_gp =  gpar(fontsize = 12, border=FALSE),
        column_names_rot = 35,
        row_names_gp = gpar(fontsize = 12, alpha = 0.75, border = FALSE))
#draw(ht)
dev.off()

```


# Plot eigengene values 

View module eigengene data and make dataframe for Strader plots.  
```{r}
head(MEs)
names(MEs)
Strader_MEs <- MEs
Strader_MEs$Sym_AFDW.mg.cm2 <- datTraits$Sym_AFDW.mg.cm2
Strader_MEs$sample_id <- rownames(Strader_MEs)
head(Strader_MEs)

Strader_MEs<-Strader_MEs%>%
  droplevels() #drop unused level

dim(Strader_MEs)
head(Strader_MEs)
```

Plot mean module eigengene for each module.  

```{r}
#convert wide format to long format for plotting  
plot_MEs<-Strader_MEs%>%
  gather(., key="Module", value="Mean", ME35:ME45)

expression_plots<-plot_MEs%>%
  group_by(Module) %>%
  #filter(Module %in% c("ME38", "ME48", "ME2"))%>%
  
  ggplot(aes(x=Sym_AFDW.mg.cm2, y=Mean)) +
  facet_wrap(~ Module)+
  geom_point()+
  geom_smooth()+
  #ylim(-0.5,1) +
  geom_hline(yintercept = 0, linetype="dashed", color = "grey")+
  theme_bw() + 
  theme(axis.text.x=element_text(angle = 45, hjust=1, size = 12), #set x-axis label size
        axis.title.x=element_text(size = 14), #set x-axis title size
        axis.ticks.x=element_blank(), #No x-label ticks
        #axis.title.y=element_blank(), #No y-axis title
        axis.text.y=element_text(size = 14), #set y-axis label size, 
        panel.border = element_rect(color = "black", fill = NA, size = 1), #set border
        panel.grid.major = element_blank(), #Set major gridlines
        panel.grid.minor = element_blank(), #Set minor gridlines
        axis.line = element_line(colour = "black"), #Set axes color
        plot.background=element_blank(),
        plot.title = element_text(size=22)); expression_plots
```




































Now we're ready to run WGCNA!

```{r, cache=TRUE}
picked_power = 5
temp_cor <- cor       
cor <- WGCNA::cor         # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk_Apul <- blockwiseModules(datExpr,                # <= input here

                          # == Adjacency Function ==
                          power = picked_power,                # <= power here
                          networkType = "signed",

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 30,
                          maxBlockSize = 5000,

                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,

                          # == TOM == Archive the run results in TOM file (saves time)
                          saveTOMs = F,
                          saveTOMFileBase = "ER",

                          # == Output Options
                          numericLabels = T,
                          verbose = 3)


cor <- temp_cor     # Return cor function to original namespace

```






Take a look
```{r}
# Convert labels to colors for plotting
mergedColors = labels2colors(netwk_Apul$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(
  netwk_Apul$dendrograms[[1]],
  mergedColors[netwk_Apul$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
```


```{r}
module_df_Apul <- data.frame(
  gene_id = names(netwk_Apul$colors),
  colors = labels2colors(netwk_Apul$colors)
)

module_df_Apul[1:5,]
```

```{r}
# Get Module Eigengenes per cluster
MEs0_Apul <- moduleEigengenes(datExpr, mergedColors)$eigengenes

# # Reorder modules so similar modules are next to each other
# MEs0_Apul <- orderMEs(MEs0_Apul)
# module_order_Apul = names(MEs0_Apul) %>% gsub("ME","", .)

# Add treatment names
MEs0_Apul$sample = row.names(MEs0_Apul)

MEs0_Apul$Timepoint <- metadata_ordered$Timepoint[match(metadata_ordered$AzentaSampleName, MEs0_Apul$sample)]

MEs0_Apul$ColonyID <- metadata_ordered$ColonyID[match(metadata_ordered$AzentaSampleName, MEs0_Apul$sample)]
MEs0_Apul$Timepoint <- metadata_ordered$Timepoint[match(metadata_ordered$AzentaSampleName, MEs0_Apul$sample)]
MEs0_Apul$Code <- paste0(MEs0_Apul$ColonyID, "_", MEs0_Apul$Timepoint)

phys<-phys%>%mutate(Timepoint=if_else(timepoint=="timepoint1","TP1", 
                        if_else(timepoint=="timepoint2", "TP2", 
                                if_else(timepoint=="timepoint3", "TP3", 
                                  if_else(timepoint=="timepoint4", "TP4", NA)))))

phys$Timepoint

phys$Code <- paste0(phys$colony_id_corr, "_", phys$Timepoint)

MEs0_Apul_phys<-left_join(MEs0_Apul, phys, by="Code")

# tidy & plot data
mME_Apul = MEs0_Apul_phys %>%
  select(ColonyID, Code, timepoint, Rd, Am, contains("ME"))%>%
  select(!Timepoint.x)%>%
  select(!Timepoint.y)%>%
  select(!timepoint)%>%

  pivot_longer(-c(ColonyID, Code, Rd, Am)) %>%
  mutate(
    name = gsub("ME", "", name),
    # name = factor(name, levels = module_order)
  )

mME_Apul %>% ggplot(., aes(x=Rd, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = "Module-trait Relationships", y = "Modules", fill="corr")
```












```{r}
# Check which modules include miRNAs
module_df_Apul %>%
  filter(grepl("mir",gene_id)) %>%
  pull(colors) %>%
  unique()

module_df_Apul %>%
  filter(grepl("mir",gene_id)) %>%
  arrange(colors) %>%
  head(n=38)
```

```{r}
# pick out a few modules of interest. Let's do some of the modules that contain previously described miRNAs, since we have the best idea of their function
modules_of_interest = c("grey", "lightyellow")
# Define the colors corresponding to the modules of interest
module_colors <- c("grey" = "black", "lightyellow" = "yellow")

# Pull out list of genes in that module
submod_Apul = module_df_Apul %>%
  subset(colors %in% modules_of_interest)

row.names(module_df_Apul) = module_df_Apul$gene_id

subexpr_Apul = t(Apul_counts_WGCNA_RNAq75)[submod_Apul$gene_id,]

submod_df_Apul = data.frame(subexpr_Apul) %>%
  mutate(
    gene_id = row.names(.)
  ) %>%
  pivot_longer(-gene_id) %>%
  mutate(
    module = module_df_Apul[gene_id,]$colors
  )

submod_df_Apul %>% ggplot(., aes(x=name, y=value, group=gene_id)) +
  geom_line(aes(color = module),
            alpha = 0.2) +
  scale_color_manual(values = module_colors) +
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 90)
  ) +
  facet_grid(rows = vars(module)) +
  labs(x = "treatment",
       y = "normalized expression")
```





